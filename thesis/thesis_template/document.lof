\addvspace {10\p@ }
\addvspace {10\p@ }
\contentsline {figure}{\numberline {2.1}{\ignorespaces Przyk\IeC {\l }ad zautomatyzowanej linii technologicznej wykorzystuj\IeC {\k a}cej system wizyjny\cite {Vision_systems_article}}}{4}{figure.2.1}
\contentsline {figure}{\numberline {2.2}{\ignorespaces Przyk\IeC {\l }ad obraz\IeC {\'o}w u\IeC {\.z}ywanych w testowaniu pozycji i orientacji element\IeC {\'o}w\cite {Machine_Vision_Intro}}}{5}{figure.2.2}
\contentsline {figure}{\numberline {2.3}{\ignorespaces Przyk\IeC {\l }ad wizyjnej identyfikacji\cite {Machine_Vision_Intro}}}{5}{figure.2.3}
\contentsline {figure}{\numberline {2.4}{\ignorespaces Procesor \textit {QorlQ Layerscape LS1028} do aplikacji przemys\IeC {\l }owych firmy NXP, wyposa\IeC {\.z}ony w dwa rdzenie ARMv8\cite {NXP_ARM}}}{6}{figure.2.4}
\contentsline {figure}{\numberline {2.5}{\ignorespaces Structura mikrokontrolera \textit {STM32F401CC}\cite {STM32_microcontrollers}}}{7}{figure.2.5}
\addvspace {10\p@ }
\contentsline {figure}{\numberline {3.1}{\ignorespaces Schemat cyklu pobierania i wykonania instrukcji przez CPU \cite {OS_Stallings}}}{8}{figure.3.1}
\contentsline {figure}{\numberline {3.2}{\ignorespaces Hierarchia pami\IeC {\k e}ci\cite {OS_Stallings}}}{9}{figure.3.2}
\contentsline {figure}{\numberline {3.3}{\ignorespaces Tr\IeC {\'o}jpoziomowa organizacja pami\IeC {\k e}ci cache \cite {OS_Stallings}}}{10}{figure.3.3}
\contentsline {figure}{\numberline {3.4}{\ignorespaces Przyk\IeC {\l }ad 4-fazowego potoku(pipeline) procesora \cite {Inside_Machine}}}{10}{figure.3.4}
\contentsline {figure}{\numberline {3.5}{\ignorespaces Intel Core i7, przyk\IeC {\l }ad wielordzeniowego procesora wykorzystuj\IeC {\k a}cego model \textbf {SMT} \cite {OS_Stallings}}}{11}{figure.3.5}
\contentsline {figure}{\numberline {3.6}{\ignorespaces Rodzaje implementacji \textbf {TLP}}}{12}{figure.3.6}
\contentsline {figure}{\numberline {3.7}{\ignorespaces Wykorzystanie \texttt {pthread\_join} do synchronizacji w\IeC {\k a}tk\IeC {\'o}w\cite {POSIX_article}}}{14}{figure.3.7}
\contentsline {figure}{\numberline {3.8}{\ignorespaces Model tworzenia w\IeC {\k a}tk\IeC {\'o}w w OpenMP\cite {openmp_blaise}}}{17}{figure.3.8}
\contentsline {figure}{\numberline {3.9}{\ignorespaces Schemat rdzenia procesora wykorzystuj\IeC {\k a}cego architektur\IeC {\k e} SIMD \cite {Intro_GPU}}}{22}{figure.3.9}
\contentsline {figure}{\numberline {3.10}{\ignorespaces Por\IeC {\'o}wnanie budowy CPU wzgl\IeC {\k e}dem GPU\cite {OS_Stallings}}}{22}{figure.3.10}
\contentsline {figure}{\numberline {3.11}{\ignorespaces Przestrze\IeC {\'n} indeksowa OpenCL \cite {OpenCL_spec}}}{23}{figure.3.11}
\contentsline {figure}{\numberline {3.12}{\ignorespaces Model pami\IeC {\k e}ci urz\IeC {\k a}dzenia OpenCL \cite {OpenCL_spec}}}{24}{figure.3.12}
\addvspace {10\p@ }
\contentsline {figure}{\numberline {4.1}{\ignorespaces Diagram stan\IeC {\'o}w, dla enkodera o 3 bitowym rejestrze przesuwnym i dw\IeC {\'o}ch sumatorach modulo-2 z wielomianami $g_1 = 111, g_2 = 101$ \cite {Comm_Sklar}}}{28}{figure.4.1}
\contentsline {figure}{\numberline {4.2}{\ignorespaces Diagram kratowy, dla enkodera o 3 bitowym rejestrze przesuwnym i dw\IeC {\'o}ch sumatorach modulo-2 z wielomianami $g_1 = 111, g_2 = 101$ \cite {Comm_Sklar}}}{29}{figure.4.2}
\contentsline {figure}{\numberline {4.3}{\ignorespaces Rodzaje modulacji sygna\IeC {\l }u cyfrowego \cite {Comm_Sklar}\cite {modulacja_put}}}{30}{figure.4.3}
\contentsline {figure}{\numberline {4.4}{\ignorespaces Dekodowanie z wykorzystaniem algorytmu Viterbiego dla sekwencji zakodowanej enkoderem z 3 bitowym rejestrem przesuwnym i dwoma sumatorami modulo-2 o wielomianach $g_1 = 111, g_2 = 101$ \cite {Comm_Sklar}}}{30}{figure.4.4}
\contentsline {figure}{\numberline {4.5}{\ignorespaces Lokalne tranzycje diagramu kratowego dla obrazu cyfrowego\cite {Mazurek_Robot_Viterbi}}}{31}{figure.4.5}
\addvspace {10\p@ }
\addvspace {10\p@ }
\addvspace {10\p@ }
\addvspace {10\p@ }
\addvspace {10\p@ }
