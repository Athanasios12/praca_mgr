\documentclass[document.tex]{subfiles}
\begin{document}

\chapter{Algorytm Viterbiego}
\section{Opis działania i zastosowania}
\indent Alogorytm Viterbiego został stworzony i przeanalizowany przez A.J. Viterbiego w 1967r. Jego zadaniem było dekodowanie kodów splotowych. Później odkryto że posiada cechy programowania dynamicznego i wykorzystuje maksymalne prawdopodobieństwo do określenia optymalnego zestawu tranzycji pomiędzy stanami. Algorytm został oryginalnie opracowany z myślą o zastosowaniach w telekomunikacji, ale znalazł zastosowanie w innych dziedzinach, m.in. w przetwarzanie obrazów, lokalizacji i rozpoznawaniu obiektów.\cite{viterbi_tutorial}
\\
\indent Główne zastosowanie algorytmu Viterbiego polega na
dekodowaniu informacji zakodowanych przy pomocy kodów splotowych. Sekwencja kodowana $m = m_1, m_2,...,m_n$, gdzie 
$m_i$ reprezentuje pojedynczy bit informacji, a indeks oznacza kolejność przesyłania. Enkoder splotowy przekształca informację wejściową w zakodowaną sekwencję $U = G(m)$.
Wykorzystuje do tego rejestr przesuwający, sumatory modulo-2 oraz wielomiany generujące(\textit{generator polynomials}) określające związek sumatorów z rejestrem.\cite{Comm_Sklar}\cite{viterbi_tutorial}

\begin{figure}[h]
\includegraphics[scale=0.45]{conv_encoder}
\caption{Diagram stanów, dla enkodera o 3 bitowym rejestrze przesuwnym 
i dwóch sumatorach modulo-2 z wielomianami $g_1 = 111, g_2 = 101$ \protect\cite{Comm_Sklar}}
\label{fig:encoder}
\end{figure}

\clearpage
\indent Enkoder splotowy należy do klasy urządzeń zwanych automatami skończonymi(\textit{finite-state machines}), które zachowują informację o poprzednich sygnałach.
Jego działanie można zaprezentować w postaci diagramu stanów(\textit{state diagram}). Bieżący stan reprezentują pierwsze $K - 1$ bity rejestru o pojemności K, a przejścia pomiędzy stanami są określane przez kody wyjściowe.
Dla enkodera z 3 bitowym rejestrem przesuwającym i 2 bitowym wyjściem, stany są określone jako kolejno
$00, 01, 10, 11$. Diagram \ref{fig:encoder} przedstawia omawiany typ enkodera, ze wszystkimi możliwymi 
tranzycjami. Widoczne są dwa rodzaje przejść pomiędzy stanami - dla bitu wejściowego będącemu jedynką oraz dla zera. Do wizualizacji kolejnych tranzycji w czasie gdy ładowane są nowe dane do rejestru przesuwającego,
używane są diagramy kratowe(\textit{trellis diagram}).\cite{kody_splotowe}\cite{Comm_Sklar}\cite{viterbi_tutorial}
Kolumny diagramu oznaczają stany rejestru, wiersze kolejne momenty czasu $t_1, t_2, ..., t_n$. Linie łączące ze są węzły diagramu oznaczają tranzycje, które są wyzwalane pojawieniem się nowego bitu sygnału wejściowego w rejestrze enkodera(patrz rys. \ref{fig:encoder_trellis}).

\begin{figure}[h]
\includegraphics[scale=0.8]{encoder_trellis}
\caption{Diagram kratowy, dla enkodera o 3 bitowym rejestrze przesuwnym 
i dwóch sumatorach modulo-2 z wielomianami $g_1 = 111, g_2 = 101$ \protect\cite{Comm_Sklar}}
\label{fig:encoder_trellis}
\end{figure}

%5/31
\indent Po zakodowaniu informacji jest ona następnie poddawana modulacji - nałożenia wejściowego sygnału na analogowy sygnał nośny modulatora.\cite{Comm_Sklar}\cite{modulacja_put} Sygnał cyfrowy ze względu na małą częstotliwość jest podatny na zakłócenia w trakcie transferu. Stosując modulację 
sygnałem analogowym o wyższej częstotliwości możliwe jest przesyłanie informacji na większe odległości oraz zmniejszenie wpływu zakłóceń.
Sygnałem nośnym najczęściej są sygnały sinusoidalne, np. w postaci\cite{modulacja_agh_amp}\cite{modulacja_put}:

\begin{equation}
    f_c(t) = A_c cos(\omega t + \theta)
    \label{eq:module_carrier}
\end{equation}
\myequations{Funkcja sygnału nośnego modulatora\cite{modulacja_agh_amp}}

Na podstawie równania \ref{eq:module_carrier} można stwierdzić że występują trzy parametry, na które można wpłynąć do modyfikacji modulowanego sygnału - amplituda $A_c$, częstotliwość $\omega$ oraz faza $\theta$. Dlatego wyróżniamy trzy rodzaje modulacji(patrz rys.\ref{fig:modulation}):
\begin{itemize}
    \item modulacja częstotliwości - jest osiągana poprzez zmianę częstotliwości sygnału w zależności, czy w danym momencie występuje zmiana z 0 na 1(zwiększenie częstotliwości), czy z 1 na 0(zmniejszenie częstotliwości).
    \item modulacja amplitudy - polega na zmodyfikowaniu amplitudy sygnału nośnego przez amplitudę sygnału zakodowanego.
    \item modulacja fazy - różnica pomiędzy 0 i 1 w sygnale wejściowym jest reprezentowana przez zmianę startu sygnału sinusoidalnego nośnika, np. 0\degree dla 0 i 180\degree dla 1.
\end{itemize}
\clearpage
\begin{figure}[h]
\includegraphics[scale=0.55]{modulation}
\caption{Rodzaje modulacji sygnału cyfrowego \protect\cite{Comm_Sklar}\cite{modulacja_put}}
\label{fig:modulation}
\end{figure} 

\indent Odbiornik dostaje zakodowaną, modulowaną i zakłóconą informację. W pierwszej fazie odczytywania przesłanego sygnału niezbędna jest jego demodulacja. Polega ona na odzyskaniu sygnału z wyjścia enkodera przed modulacją.
Dla sygnału modulowanego amplitudowo \textbf{AM} demodulacja może być przeprowadzona poprzez użycie detektora diodowego oraz filtracji niepożądanych wysokich częstotliwości.\cite{demodulation_am}
W przypadku demodulacji częstotliwościowej \textbf{FM} i fazy \textbf{PM}, wykorzystywane są detektory \textbf{PLL}(\textit{Phase Locked Loop} - pętla synchronizacji fazy)\cite{demodulation_fmpm}.

\begin{figure}[h]
\includegraphics[scale=0.8]{viterbi_trellis}
\caption{Dekodowanie z wykorzystaniem algorytmu Viterbiego dla sekwencji zakodowanej enkoderem z 3 bitowym rejestrem przesuwnym i dwoma sumatorami modulo-2 o wielomianach $g_1 = 111, g_2 = 101$ \protect\cite{Comm_Sklar}}
\label{fig:viterbi_trellis}
\end{figure}

\indent W celu odczytania informacji zakodowanej enkoderem splotowym stosowany jest dekoder
wykorzystujący algorytm Viterbiego. Wykorzystuje on strukturę diagramu kratowego do obliczenia optymalnej
kombinacji przejścia pomiędzy jego stanami(patrz rys.\ref{fig:viterbi_trellis}). Do określenia najlepszego wariantu przejścia ze stanu w czasie $t_i$ do stanu $t_{i+1}$, wybierana jest tranzycja o najmniejszej odległości Hamminga\cite{Comm_Sklar} względem fragmentu kodu po demodulacji. Odległość Hamminga określana jest przez liczbę pozycji, na których różnią się dwa ciągi kodu.
Jeśli występuje kilka możliwych przejść do danego stanu, wybierane jest te, które ma największe prawdopodobieństwo - najmniejszą odległość Hamminga, a reszta jest odrzucana. Wybór najlepszego zestawu tranzycji
dla całego diagramu jest określony przez skumulowaną odległość Hamminga dla końcowego stanu. 
Na podstawie otrzymanej optymalnej listy przejść odczytywana jest zakodowana informacja .\cite{Comm_Sklar}\cite{viterbi_tutorial}\cite{viterbi_mit}
 
%tutaj może jakies podumowanie -patrz tutorial viterbi viterbi mit
\section{Wykrywanie linii na obrazie cyfrowym z wykorzystaniem algorytmu Viterbiego}
\indent Algorytm Viterbiego, którego celem jest znalezienie optymalnej ścieżki w diagramie kratowym, może zostać zastosowany w analogiczny sposób do wyznaczenia optymalnego zestawu współrzędnych pikseli na obrazie cyfrowym.
W tym wypadku piksele odpowiadają stanom rejestru przesuwającego, a odległość Hamminga wykorzystana do obliczenia najlepszej tranzycji jest zastąpiona funkcją intensywności pikseli. Zgodnie z zaproponowanym rozwiązaniem w \cite{viterbi_ch_9} dla każdego piksela określane jest najlepsze przejście do następnej kolumny/wiersza.

\begin{figure}[h]
\includegraphics[scale=0.8]{viterbi_line_trellis}
\caption{Lokalne tranzycje diagramu kratowego dla obrazu cyfrowego\protect\cite{Mazurek_Robot_Viterbi}}
\label{fig:viterbi_trellis}
\end{figure}

Zakładając szukanie linii pionowej, przetwarzanie obrazu zaczyna się od pierwszego wiersza $y = 0$. 
Dla każdego z pikseli w pierwszym wierszu jest przypisana początkowa wartość akumulowana $V_{x, 0} = 0$
Dla piksela o współrzędnej $x, y$ rozpatrywana jest jego intensywność oraz intensywność jego sąsiadów.
Współrzędne sąsiednich pikseli są określane przedziałem $x + g$, gdzie $g\in \langle g_l;g_h\rangle$, np. $g_l = -2,\ g_h = 2$, czyli $g\in \{-2, -1, 0, 1, 2\}$. Wartość $V_{x,y+1}$ może być wyznaczana na podstawie równania \ref{eq:V}\cite{Mazurek_Robot_Viterbi}\cite{viterbi_ch_6}:

\begin{equation}
    V_{x, y+1} = max(V_{x+g, y} + d_{x+g, y}^{x,y+1}),\ g\in\{-2,-1,0,1,2\}
    \label{eq:V}
\end{equation}
\myequations{Równanie wyboru współrzędnej dla wykrywania linii wykorzystując algorytm
Viterbiego\cite{Mazurek_Robot_Viterbi}\cite{viterbi_ch_6}}


,gdzie $V_{x+g, y}$ - skumulowana dotychczasowa intensywność dla współrzędnych piksela ($x+g, y$), 
\\
$d_{x+g, y}^{x,y+1}$ - intensywność piksela o współrzędnych ($x+g, y$),  $V_{x, y+1}$ - wynikowa skumulowana intensywność dla piksela o współrzędnych (${x, y+1}$).
\\
Wartości $g$ określające najlepsze lokalną tranzycje są zapisywane w tablicy indeksów $L$ zgodnie z równaniem \ref{eq:L}\cite{Mazurek_Robot_Viterbi}\cite{viterbi_ch_6}:
<<<<<<< HEAD

\begin{equation}
   L_{y}^{x, y+1} = \argmax_{g}\limits(V_{x+g, y} + d_{x+g, y}^{x,y+1}),\ g\in\{-2,-1,0,1,2\}
    \label{eq:L}
\end{equation}
\myequations{Wyznaczanie tablicy indeksów dla algorytmu Viterbiego\cite{Mazurek_Robot_Viterbi}\cite{viterbi_ch_6}}

Indeksy są obliczane dla wszystkich rozpatrywanych wierszy. Po wyznaczeniu tablicy $L$ sprawdzany jest ostatni wiersz $y_max$ w celu określenia kolumny z największą skumulowaną intensywnością $x_max$ \ref{eq:xmax}:

\begin{equation}
   x_{y_{max}} = \max_{x}\limits(V_{x, y_max})
    \label{eq:xmax}
\end{equation}
\myequations{Określenie piksela z największą skumulowaną intensywnością dla ostatniej rozpatrywanej kolumny obrazu\cite{Mazurek_Robot_Viterbi}\cite{viterbi_ch_6}}

Wsteczne przetwarzanie tablicy indeksów $L$ pozwala wyznaczyć pozycję fragmentu linii dla pierwszej kolumny $y = 1$ \ref{eq:L_back}:

\begin{equation}
   x_{y-1} = x_y + L_{y-1}^{x,y},\ y = y_max,...,y_{start + 1}
    \label{eq:L_back}
\end{equation}
\myequations{Określenie piksela z największą skumulowaną intensywnością dla ostatniej rozpatrywanej kolumny obrazu\cite{Mazurek_Robot_Viterbi}\cite{viterbi_ch_6}}

=======

\begin{equation}
   L_{y}^{x, y+1} = \argmax_{g}\limits(V_{x+g, y} + d_{x+g, y}^{x,y+1}),\ g\in\{-2,-1,0,1,2\}
    \label{eq:L}
\end{equation}
\myequations{Wyznaczanie tablicy indeksów dla algorytmu Viterbiego\cite{Mazurek_Robot_Viterbi}\cite{viterbi_ch_6}}

Indeksy są obliczane dla wszystkich rozpatrywanych wierszy. Po wyznaczeniu tablicy $L$ sprawdzany jest ostatni wiersz $y_max$ w celu określenia kolumny z największą skumulowaną intensywnością $x_max$ \ref{eq:xmax}:

\begin{equation}
   x_{y_{max}} = \max_{x}\limits(V_{x, y_max})
    \label{eq:xmax}
\end{equation}
\myequations{Określenie piksela z największą skumulowaną intensywnością dla ostatniej rozpatrywanej kolumny obrazu\cite{Mazurek_Robot_Viterbi}\cite{viterbi_ch_6}}

Wsteczne przetwarzanie tablicy indeksów $L$ pozwala wyznaczyć pozycję fragmentu linii dla pierwszej kolumny $y = 1$ \ref{eq:L_back}:

\begin{equation}
   x_{y-1} = x_y + L_{y-1}^{x,y},\ y = y_max,...,y_{start + 1}
    \label{eq:L_back}
\end{equation}
\myequations{Określenie piksela z największą skumulowaną intensywnością dla ostatniej rozpatrywanej kolumny obrazu\cite{Mazurek_Robot_Viterbi}\cite{viterbi_ch_6}}

Do obliczenia wyników dla następnych kolumn zwiększa się $y_{start}$ i od nowa oblicza się tablice $V$ i $L$.
%chyba ok
\section{Implementacja detekcji linii języku C++}
\indent Tworząc aplikację wykorzystującą algorytm Viterbiego do lokalizacji linii
na obrazie cyfrowym skorzystano z nowych funkcjonalności standardu C++11. 
Zdjęcia na, których szukano linii były wczytywane używając funkcji biblioteki
CImg. Reprezentowane przez obiekty \code{Cimg<T>}, dane pikseli zdjęcia były kopiowane do
dynamicznie zaalokowanych tablic przypisanych do obiektów \code{unique\_ptr}. Skorzystano inteligentnego wskaźnika - \code{unique\_ptr} , ze względu na funkcję automatycznego zwalniania zaalokowanych zasobów po wywołaniu jego destruktora\code{unique\_ptr}.  
Wszystkie warianty implementacji detekcji linii zostały zawarte w klasie \code{Viterbi}, 
jako jej metody.
dynamicznie zaalokowanych tablic jednowymiarowych przypisanych do obiektów \code{unique\_ptr}. 
Skorzystano z obiektu inteligentengo wskaźnika \code{unique\_ptr} , 
ze względu na funkcję automatycznego zwalniania zaalokowanych zasobów po wywołaniu jego destruktora\code{unique\_ptr}.  


%opis listinigu opencl_viterbi.cpp
\subsection{Wersja szeregowa}

%opisać listingi i pododawać wzory, ew pseudokod 

%listing z viterbiLineDetect - nie pokazywac całego
\lstinputlisting[language={C++}, label={lst:viterbi_serial}, caption=Szeregowa implementacja algorytmu Viterbiego do wykrywania linii, linerange=224-297, firstnumber=224]{viterbi_source/Viterbi.cpp} 

%fragment inicjalizacja
\lstinputlisting[language={C++}, label={lst:viterbi_serial}, caption=Szeregowa implementacja algorytmu Viterbiego do wykrywania linii, linerange=224-240, firstnumber=224]{viterbi_source/Viterbi.cpp} 


%opisać wszystkie fragmenty z odniesieniem do schematu ogólnego algorytmu - shcemat z atykułów i wzory
\subsection{Wersja równoległa - C++11}
To jest podrozdział 2 rozdziału 2
\subsection{Wersja równoległa - OpenCL}
To jest podrozdział 3 rozdziału 2
\end{document}