\documentclass[document.tex]{subfiles}
\begin{document}

\chapter{Metody równoległego przetwarzania danych}

\section{Wielowątkowość aplikacji dla języka C/C++}
%wstęp równoległość
\indent Najbardziej popularnym podejściem do pisania aplikacji jest sekwencyjne wykonywanie
instrukcji przez procesor - tylko jedna z nich może być wykonywana w tym samym czasie.
Jednak dużą ilość problemów można rozbić na niezależne fragmenty,
które mogą być rozwiązywane równolegle. Obecnie powszechnie stosowane procesory wielordzeniowe dają możliwość rozdzielenia obciążenia obliczeniowego na poszczególne rdzenie oraz dla każdego rdzenia na osobne wątki.\cite{Computer_Architecture_Patterson_Hennesy}\cite{Parallel_computing_article} \\
 %wątek def i opis
 \indent Wątek jest to podproces, który posiada własny stos, zestaw rejestrów, ID, priorytet i wykonuje określony fragment kodu programu. 
 W przeciwieństwie do prawdziwego procesu posiada wspólną pamięć globalną i sterty, dzieloną z innymi wątkami istniejącymi w ramach tego samego procesu. 
 Wątki procesu wykonują się równolegle, dopóki nie potrzebują dostępu do zasobów we wspólnej pamięci.\cite{POSIX_article}\cite{POSIX_tutorial} 
 Wtedy ze względu na problem błędnego odczytu, bądź zapisu wartości w pamięci kiedy inny wątek ją już nadpisał, może spowodować niewłaściwe działanie programu. 
 Fragmenty kodu gdzie może dojść do tego problemu nazywane są sekcjami krytycznymi. Do zabezpieczania sekcji krytycznych programu stosowane są blokady - muteksy(Mutual exclusions) oraz zmienne warunkowe.
 Zastosowanie muteksa powoduje, że w danym momencie tylko jeden wątek może wykonywać kod chroniony przez tą blokadę i dopóki nie opuści chronionej sekcji krytycznej inny wątek nie może zacząć jej wykonywać. 
 Zmienne warunkowe stosowane są do sygnalizowania postępu danego wątku, tak aby inny mógł kontynuować wykonywanie operacji sekcji krytycznej. 
 Stosowane razem z blokadami umożliwiają właściwą synchronizację pracy wątków tego samego procesu.
\cite{POSIX_Butenhof}\cite{C++_Stroustrup} \\
 %watek - wady i zalety 
\indent Używanie wielowątkowości w aplikacjach pozwala na wykorzystanie możliwości sprzętowych procesorów wielordzeniowych do obliczeń równoległych.
Ponadto wielowątkowy model programowania umożliwia wykonywanie przez proces dalszych działań w czasie czasochłonnych obliczeń, bądź czekania na zdarzenie blokujące - takie jak ,np.sygnał z urządzenia peryferyjnego.
Wadą tworzenia dodatkowych wątków w programie jest narzut obliczeniowy
związany z ich synchronizacją(omawiany wcześniej problem wyścigu oraz zjawisko zakleszczenia - wątki czekają na siebie nawzajem żeby móc kontynuować obliczenia) oraz dostępem do wspólnego obszaru pamięci.\cite{POSIX_Butenhof}\cite{C++_Stroustrup} \\
%podsumowanie
\indent W tym rozdziale zostaną omówione różne metody tworzenia aplikacji
wielowątkowych w języku C/C++. Skupiono się na bibliotekach dla tych języków
programowania ze względu na ich popularność w tworzeniu rozwiązań dla systemów wbudowanych, która wynika z wysokiej wydajności kodu i małego zużycia pamięci w porównaniu do języków interpretowanych, np. Java, Python.\cite{C++_Stroustrup}\cite{C_King}

\subsection{Biblioteka POSIX dla systemów Unix}
\indent Dla systemów z rodziny Unix w 1995 ustalony został standard programowania 
wielowątkowego nazywany POSIX threads, w skrócie Pthreads. API Pthreads zostało zdefiniowane jako zestaw typów i procedur w języku C, zawarte w pliku nagłówkowym
\code{<pthread.h>} i bibliotece libpthread.\cite{POSIX_article}
Korzystanie z biblioteki Pthreads do tworzenia wątków generuje mniejszy narzut
niż tworzenie osobnych procesów do równoległego przetwarzania danych.\cite{POSIX_article} 
\\
\indent Wątek w programie jest reprezentowany poprzez zmienną typu \code{pthread\_t}, 
najczęsciej zdefiniowaną jako zmienna statyczna lub jako struktura, która jest zaalokowana na stercie.\cite{POSIX_Butenhof}\cite{POSIX_article}\cite{POSIX_tutorial} 
Do każdego stworzonego wątku przypisana jest funkcja, którą będzie wykonywał.
Funkcja powinna przyjmować jako argument zmienną wskaźnikową \code{void*} i zwracać
wartość tego samego typu. Za tworzenie nowego wątku odpowiedzialna jest funkcja \code{pthread\_create}. Przyjmuje ona adres funkcji oraz argument z jakim ma zostać wywołana.
Wywołanie \code{pthread\_create} oprócz rozpoczęcia nowego wątku zwraca identyfikator
\code{pthread\_t}, który będzie wykorzystywany do odnoszenia się do stworzonego wątku.
Wątek zostaje zakończony jeśli wykona wszystkie instrukcje swojej funkcji lub jeśli wywoła procedurę \code{pthread\_exit}. \cite{POSIX_Butenhof}

\begin{figure}[h]
\includegraphics[scale=0.7]{posix_thread_tree}
\caption{Wykorzystanie \code{pthread\_join} do synchronizacji wątków\protect\cite{POSIX_article}}
\label{fig:inspekcja}
\end{figure}

Jedną z podstawowych metod synchronizacji pomiędzy wątkami jest użycie funkcji \code{pthread\_join}, która powoduje zatrzymanie dalszego wykonywania instrukcji dopóki stworzony wątek nie zakończy pracy.
Tylko wątki, które został stworzone z atrybutem \code{joinable}, 
a nie \code{detached}(odłączony) mogą używać tego rodzaju synchronizacji.\cite{POSIX_article}(patrz \ref{lst:basic_thread}). % kontynuować o wątkach
\\
\lstinputlisting[language=C, label={lst:basic_thread}, caption=Przykład tworzenia i uruchamiania wątków]{code_snippets/posix_example_0.c} 

\indent W celu zapewnienia bezpieczeństwa w współdzieleniu zasobów
pomiędzy wątkami podczas wykonywania sekcji krytycznych,
najpopularniejsze jest wykluczenie jednoczesnego czytanie bądź zapisu
wartości w dzielonej pamięci. Używane do tego są zmienne wzajemnego
wykluczenia - w skrócie muteks(mutual exclusion). Muteks jest szczególnym przypadkiem semaforu Dijkstry - semaforem binarnym 
o zbiorze wartości {0, 1}.\cite{POSIX_Butenhof}\cite{POSIX_tutorial}\cite{POSIX_article} 
W bibliotece POSIX threads muteks jest reprezentowany jako zmienna typu \code{pthread\_mutex\_t}. W celu posiadania globalnego
zasięgu deklarowana jest jako zmienna \code{static} lub \code{extern}.
\cite{POSIX_Butenhof}\cite{C_King}(patrz\ref{lst:mutex_thread})
W celu deklaracji muteksa wykorzystywane jest makro \code{PTHREAD\_MUTEX\_INITIALIZER}(patrz . Jeśli muteks jest używany jako
element dynamicznie alokowanej struktury, musi zostać zainicjalizowany 
wywołaniem funkcji \code{pthread\_mutex\_init}. Ponadto musi być w ten
sposób inicjalizowany, jeśli nie ma posiadać domyślnych atrybutów.
Niezbędne jest po zakończeniu używania muteksa, zwolnienie zaalokowanej pamięci, poprzez wykorzystanie funkcji \code{pthread\_mutex\_destroy}.\cite{POSIX_Butenhof} 
\\
\lstinputlisting[language=C, label={lst:mutex_thread}, caption=Przykład wykorzystanie muteksa do synchronizacji
aplikacji wielowątkowej]{code_snippets/posix_example_1.c}

\indent Pthreads do komunikacji pomiędzy wątkami wykorzystuje zmienne
warunkowe(condition variables), które mają informować o stanie 
współdzielonych zasobów. Używane razem z muteksami, w atomiczny 
sposób zwalniają blokadę sekcji krytycznej, dopóki inny wątek nie
zasygnalizuje kontynuacji używając funkcji \code{pthread\_cond\_signal}. Dzięki temu inny wątek może kontynuować pracę 
zanim zostanie wykonana chroniona sekcja krytyczna.

\indent Dzięki przedstawionym metodom sygnalizacji stanu oraz 
blokadom, możliwe jest zaprojektowanie pożądanego podziału obciążenia
obliczeniowego. Biblioteka POSIX, choć wiekowa dalej jest stosowana
dzięki małemu narzutowi(napisana w języku C), obszernej dokumentacji 
oraz dużej ilości starego kodu, który dalej jest stosowany w nowych
rozwiązaniach systemów wbudowanych i czasu rzeczywistego.\cite{POSIX_tutorial}
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{OpenMP - wieloplatformowe API}
%żródła do tego rozdziału
%\cite{openmp_pacheco}
%\cite{openmp_spec}
%\cite{openmp_guide}
%\cite{openmp_slides}
%--------------------------
\indent Podobnie jak Pthreads, OpenMP jest biblioteką wykorzystującą
model współdzielenia pamięci do programowania równoległego. Zawiera wsparcie dla języków C, C++ oraz Fortran.
OpenMP wymaga sprecyzowania przez użytkownika odpowiednich akcji, które ma wykonać kompilator, aby program wykonywał się równolegle.
\cite{openmp_pacheco}\cite{openmp_spec}
OpenMP został stworzony przez grupę naukowców i programistów, którzy
uważali, że używanie API Pthreads jest skomplikowane dla dużych
aplikacji. Zdecydowali się stworzyć standard wyższego poziomu, który
w przeciwieństwie do biblioteki Pthreads wymagającej od programisty zdefiniowania funkcji wykonawczej dla każdego wątku, pozwala 
na określenie dowolnego fragmentu programu, który ma być wykonany 
równolegle. Wykorzystuje do tego dyrektywy preprocesora znane jako
\code{\#pragma}.Używane są do zdefiniowania zachowań kompilatora,
które nie są zawarte w podstawowej specyfikacji języka C.
Jeśli użyty kompilator nie wspiera dyrektyw \code{\#pragma}, program
i tak ma możliwość właściwego działania; wtedy jego fragmenty mające wykonać
się równolegle zostaną obsłużone przez jeden wątek.
\cite{openmp_pacheco}\cite{C_King}\cite{openmp_spec}\cite{openmp_guide}
Oprócz zestawu dyrektyw preprocesora, OpenMP składa się z biblioteki
funkcji i makr, które wymagają dodania pliku nagłówkowego \code{<omp.h>}
z ich definicjami i prototypami.
\\
\indent Podstawową dyrektywą OpenMP jest dyrektywa \code{\#pragma omp parallel},
za pomocą której określany jest blok kodu mający być wykonany wielowątkowo.
Jeśli programista nie sprecyzuje przez ile wątków
ma być przetworzony podany fragment programu, zostanie on określony przez system
wykonawczy(zazwyczaj po jednym wątku na rdzeń).\cite{openmp_pacheco}\cite{openmp_guide}(patrz \ref{lst:openmp_0})
\\
\lstinputlisting[language=C, label={lst:openmp_0}, caption= Prosta aplikacja wykorzystująca dyrektywę \code{\#pragma omp parallel} 
\protect\cite{openmp_pacheco}]{code_snippets/openmp_example_0.c}

Powyższy prosty przykład ilustruje wykorzystanie OpenMP do równoległego
uruchomienia \code{thread\_count} wątków, gdzie każdy z nich wykona
funkcję \code{mp\_test}.Dodatkowo użyta klauzula \code{num\_threads}
modyfikuję dyrektywę tak aby stworzyła tyle wątków ile zostało 
podane w liście argumentów przy uruchomieniu programu(wskaźnik na tablicę \code{argv}). Jeśli jeden z wątków wcześniej skończy pracę od innych,
czeka aż reszta zakończ wykonywanie funkcji \code{mp\_test}.
Każdy ze stworzonych wątków otrzymuje swoje id, stopień oraz parametr
określający liczbę innych wątków w ramach tego samego bloku.
Korzystając z funkcji \code{omp\_get\_thread\_num} i \code{omp\_num\_threads}
(nagłówek \code{<omp.h>}) otrzymywane jest id i liczba współpracujących wątków.
Współdzielonym zasobem pomiędzy wątkami jest strumień wyjściowy \code{stdout}.
\cite{openmp_pacheco}\cite{openmp_slides}
\\
\indent Kolekcja wątków wykonujących blok kodu nazywana jest zespołem. Wątek,
który przetwarzał instrukcje przed dyrektywą \code{\#pragma omp parallel} 
jest zarządcą(\textbf{master}), a dodatkowe wątki są jego podwładnymi(\textbf{slave}). Kiedy wszystkie zakończą swoją pracę łączą się z
wątkiem twórcą, który wtedy kontynuuje wykonywanie dalszych instrukcji(patrz rys. \ref{fig:openmp_tree}).\cite{openmp_blaise}\cite{openmp_spec}

\begin{figure}[h]
\includegraphics[scale=0.7]{openmp_tree}
\caption{Model tworzenia wątków w OpenMP\protect\cite{openmp_blaise}}
\label{fig:openmp_tree}
\end{figure}

\indent Podobnie jak dla Pthreads OpenMP uwzględnia ochronę sekcji krytycznej 
oraz metody synchronizacji wątków. Do przeciwdziałania wyścigom i zakleszczeniom(deadlocks) pomiędzy wątkami wykorzystywane są:\cite{openmp_spec}\cite{openmp_guide}
\begin{itemize}
\item Dyrektywa \code{critical} - tylko jeden wątek może w tym samym czasie wykonywać blok strukturalny. Możliwe jest istnienie wielu sekcji \code{critical}, gdzie ich nazwy 
są używane jako globalne identyfikatory. Różne regiony \code{critical} o tej samej
nazwie są traktowane jako jedna sekcja.\cite{openmp_pacheco}\cite{openmp_blaise} 
\begin{verbatim}
#pragma omp critical [ nazwa ]
{
   blok strukturalny
}
\end{verbatim}

\item Dyrektywa \code{atomic} - wykorzystuje specjalne instrukcje sprzętowe, dzięki
czemu możliwa jest dużo szybsza realizacja sekcji krytycznej. Atomowe operacje to
takie które wykonywane są zawsze całkowicie, bez interwencji innego wątku.
Najczęściej sekcje \code{atomic} używane są do prostych operacji na licznikach
zmienianych przez kilka wątków równolegle.\cite{openmp_guide}\cite{openmp_spec}
\\
Operacje zmiany zmiennej:
\begin{verbatim}
#pragma omp atomic [ nazwa ]
{
   ++x; --x; x++; x--;
   x += expr;  x -= expr;  x *= expr;   x /= expr;  x &= expr;
   x = x+expr; x = x-expr; x = x*expr;  x = x/expr; x = x&expr;
   x = expr+x; x = expr-x; x = expr*x;  x = expr/x; x = expr&x;
   x |= expr;  x ^= expr;  x <<= expr;  x >>= expr;
   x = x|expr; x = x^expr; x = x<<expr; x = x>>expr;
   x = expr|x; x = expr^x; x = expr<<x; x = expr>>x;
}
\end{verbatim}

Operacje czytania i nadpisania zmiennej:
\begin{verbatim}
#pragma omp atomic [ nazwa ]
{
   var = x++;
   var = x; 
   x++;
   x = expr;
}
\end{verbatim}
\item Blokada \code{omp\_lock\_t} z pliku nagłówkowego \code{<omp.h>} - ogranicza dostęp
do funkcji krytycznej. Posiada pięć funkcji do manipulacji blokadą \cite{openmp_guide}\cite{openmp_blaise}:
	\begin{itemize}
	\item \code{omp\_init\_lock} - inicjalizuje blokadę. Po tym wywołaniu nie jest jeszcze ustawiona.
	\item \code{omp\_destroy\_lock} - usuwa blokadę, nie może być wcześniej ustawiona.
	\item \code{omp\_set\_lock} - próbuje ustawić blokadę. Jeśli inny wątek już wywołał tą
	funkcję, czeka aż blokada będzie znowu dostępna, wtedy zostaje ona ustawiona.
	\item \code{omp\_unset\_lock} - zwalnia blokadę, powinna być użyta tylko przez wątek,
	który ją ustawił. W innym wypadku zachowanie programu będzie niezdefiniowane.
	\item \code{omp\_test\_lock} - próbuje ustawić blokadę. Jeżeli jest już ustawiona 
	przez inny wątek, zwraca 0. Jeśli nie, blokuje sekcję krytyczną i zwraca 1.
	\end{itemize}
\end{itemize}

\indent

\cite{openmp_blaise}
%tutaj o sekcjach krytycznych - dyrektywa critical - zapewnia
%mutex dla danego bloku(218) definiowanie reduktów - automatyczna definicja
%sekcji krytycznej i wzajemne wykluczenie - podglądnąć summary działu pacheco


\subsection{Wielowątkowość w standardzie C++11}
To jest podrozdział 3 rozdziału 1


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%koniec rozdziału


\section{Programowanie równoległe z wykorzystaniem GPU}
To jest rozdział 2

\subsection{Architektura GPU i porównanie względem CPU}
To jest podrozdział 1 rozdziału 2

\subsection{Biblioteka OpenCL}
To jest podrozdział 2 rozdziału 2

%ewentualnie można coś dodać o CUDA jeśli objętościowo będzie za cienkie
\end{document}
